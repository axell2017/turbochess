<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TurboChess v0.4.2 — Mid-Strip Rebalance + Multi-King End</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root { --bg:#0a0f1a; --fg:#cfe8ff; --cyan:#48e1ff; --mag:#ff5ad6; --gold:#ffde6b; --green:#5bff95; --amber:#ffb35c; --blue:#77b5ff; }
    html, body, #root { height: 100%; margin: 0; background: radial-gradient(1200px 800px at 50% 10%, #0e1630, #070b14 70%, #05060a); color: var(--fg); font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; }

    .glass { backdrop-filter: blur(6px) saturate(120%); background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02)); border: 1px solid rgba(255,255,255,0.15); box-shadow: 0 10px 40px rgba(0,0,0,0.5), inset 0 0 60px rgba(255,255,255,0.04); }
    .neon { text-shadow: 0 0 10px rgba(72,225,255,0.7); }
    .midlineGlow { box-shadow: inset 0 0 25px rgba(72,225,255,0.35); }

    .board { position: relative; display: grid; grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr); aspect-ratio: 1 / 1; }
    .cell { position: relative; display:flex; align-items:center; justify-content:center; font-weight:600; }
    .light { background: rgba(255,255,255,0.06); }
    .dark { background: rgba(0,0,0,0.25); }
    .sqLabel { position:absolute; left:6px; bottom:4px; opacity:0.35; font-size:10px; }

    .hud { position:absolute; top:6px; right:6px; font-size:10px; padding:2px 6px; border-radius:999px; background: rgba(10, 180, 255, 0.12); border:1px solid rgba(72,225,255,0.45); color:#bfefff; text-shadow:0 0 8px rgba(72,225,255,0.6); }

    .piece { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-size:28px; filter: drop-shadow(0 6px 18px rgba(0,0,0,0.6)); }
    .w { color:#e6f6ff; text-shadow:0 0 6px rgba(72,225,255,0.7); }
    .b { color:#ffd6f3; text-shadow:0 0 6px rgba(255,90,214,0.7); }

    .sel { outline: 2px solid rgba(72,225,255,0.9); box-shadow: inset 0 0 20px rgba(72,225,255,0.55); }
    .moveDot { width:14px; height:14px; border-radius:999px; background: radial-gradient(circle at 30% 30%, rgba(72,225,255,0.9), rgba(72,225,255,0.1)); box-shadow:0 0 14px rgba(72,225,255,0.8); }

    @keyframes morphFlash { 0% { opacity:0; transform:scale(0.8);} 40%{opacity:1; transform:scale(1.15);} 100% { opacity:0; transform:scale(1);} }
    .flash { pointer-events:none; position:absolute; inset:8px; border-radius:8px; background: radial-gradient(circle, rgba(72,225,255,0.6), rgba(255,255,255,0.05) 60%, rgba(0,0,0,0) 70%); animation: morphFlash 450ms ease-out; }

    .hexLayer { position:absolute; inset:0; display:grid; grid-template-columns:repeat(8, 1fr); grid-template-rows:repeat(8, 1fr); pointer-events:none; }
    .hexCell { display:flex; align-items:center; justify-content:center; opacity:0.12; font-size:10px; }

    /* Spring pulse (subtle) */
    @keyframes springPulse { 0% { box-shadow: inset 0 0 0 rgba(91,255,149,0); background-color: transparent; } 30% { box-shadow: inset 0 0 60px rgba(91,255,149,0.28); background-color: rgba(91,255,149,0.06); } 100% { box-shadow: inset 0 0 0 rgba(91,255,149,0); background-color: transparent; } }
    .spring-flash { animation: springPulse 700ms ease-out; }

    /* I Ching heat overlays */
    .heat { position:absolute; inset:0; pointer-events:none; border-radius:2px; }
    .heat-1 { background: radial-gradient(circle at 50% 50%, rgba(255, 215, 0, 0.12), rgba(255, 215, 0, 0.02)); }
    .heat-2 { background: radial-gradient(circle at 50% 50%, rgba(255, 215, 0, 0.18), rgba(255, 215, 0, 0.03)); box-shadow: inset 0 0 18px rgba(255,215,0,0.15); }
    .heat-3 { background: radial-gradient(circle at 50% 50%, rgba(255, 215, 0, 0.24), rgba(255, 215, 0, 0.05)); box-shadow: inset 0 0 28px rgba(255,215,0,0.22), 0 0 18px rgba(255,215,0,0.18); }

    @keyframes goldCast { 0% { opacity:0; transform: scale(0.8);} 35% { opacity:1; transform: scale(1.1);} 100% { opacity:0; transform: scale(1);} }
    .gold-cast { position:absolute; inset:6px; border-radius:8px; background: radial-gradient(circle, rgba(255,215,0,0.55), rgba(255,215,0,0.0) 60%); animation: goldCast 700ms ease-out; pointer-events:none; }

    .badge { position:absolute; top:6px; left:6px; padding:2px 6px; font-size:10px; border-radius:6px; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    // v0.4.2: Mid-strip rebalance (NBR @3, Q @5) + game ends only when a side has 0 kings

    const FILES = ['a','b','c','d','e','f','g','h'];
    const IDX = (f,r) => r*8+f;

    const SEASONS = ['Spring','Summer','Autumn','Winter'];
    const DEFAULT_SEASON_CFG = { on:true, startFullMoves:5, durFullMoves:8 };
    function currentSeason(ply, cfg){
      if(!cfg || !cfg.on) return null;
      const full = Math.floor(ply/2);
      if(full < cfg.startFullMoves) return null;
      const k = Math.floor((full - cfg.startFullMoves) / cfg.durFullMoves);
      return SEASONS[((k % 4) + 4) % 4];
    }

    const initialPieces = () => {
      const pieces = [];
      for (let f=0; f<8; f++) {
        pieces.push({ t:'P', c:'w', sq: IDX(f,6), tick:0, id:`wP${f}`, hasMoved:false });
        pieces.push({ t:'P', c:'b', sq: IDX(f,1), tick:0, id:`bP${f}`, hasMoved:false });
      }
      const back = ['R','N','B','Q','K','B','N','R'];
      for (let f=0; f<8; f++) {
        pieces.push({ t:back[f], c:'w', sq: IDX(f,7) });
        pieces.push({ t:back[f], c:'b', sq: IDX(f,0) });
      }
      return pieces;
    };

    function cloneState(s){ return JSON.parse(JSON.stringify(s)); }
    function sqToFR(sq){ return [sq%8, Math.floor(sq/8)]; }
    function FRToSq(f,r){ return r*8+f; }
    function isMidStripSq(sq){ const [,r]=sqToFR(sq); return r===3 || r===4; }

    function makeInitialState(){
      return {
        pieces: initialPieces(),
        stm: 'w',
        ep: null,
        ply: 0,
        morphFlashSq: null,
        upgradeQueue: [],
        awaitingUpgrade: null,
        terminal: null,
        seasonCfg: { ...DEFAULT_SEASON_CFG },
        squareHeat: Array(64).fill(0), // 0..3
        lastCastAt: Array(64).fill(-1), // ply index when cast fired, for pulse gating
      };
    }

    function pieceAt(state, sq){ return state.pieces.find(p=>p.sq===sq); }
    function inBoard(f,r){ return f>=0 && f<8 && r>=0 && r<8; }
    function isEmpty(state, sq){ return !pieceAt(state, sq); }

    // UPDATED: mid-strip thresholds (NBR @3, Q @5) and off-strip unchanged (NBR @6, Q @8), K @9 anywhere
    function upgradeChoicesForPawn(p){
      const t = p.tick || 0; const onStrip = isMidStripSq(p.sq); const set = new Set();
      const minorThr = onStrip ? 3 : 6; // N/B/R
      const qThr = onStrip ? 5 : 8;     // Queen
      if (t >= minorThr) { set.add('N'); set.add('B'); set.add('R'); }
      if (t >= qThr) { set.add('Q'); }
      if (t >= 9) { set.add('K'); }
      return Array.from(set);
    }

    function generateMoves(state){
      const moves = []; const dir = { w:-1, b:1 };
      for (const p of state.pieces){
        if (p.c !== state.stm) continue;
        if (p.t==='P'){
          const [f,r] = sqToFR(p.sq);
          const r1=r+dir[p.c]; if (inBoard(f,r1) && isEmpty(state, FRToSq(f,r1))){
            moves.push({kind:'move', from:p.sq, to:FRToSq(f,r1)});
            if (!p.hasMoved){ const r2=r+2*dir[p.c]; if (inBoard(f,r2) && isEmpty(state, FRToSq(f,r2)) && isEmpty(state, FRToSq(f,r1))) moves.push({kind:'move', from:p.sq, to:FRToSq(f,r2), double:true}); }
          }
          for (const df of [-1,1]){ const f2=f+df, r2=r+dir[p.c]; if (!inBoard(f2,r2)) continue; const sq=FRToSq(f2,r2); const v=pieceAt(state,sq); if (v && v.c!==p.c) moves.push({kind:'move', from:p.sq, to:sq, capture:true}); }
          if (state.ep!=null){ const [ef,er]=sqToFR(state.ep); const [pf,pr]=sqToFR(p.sq); if (er===pr+dir[p.c] && Math.abs(ef-pf)===1){ const adjSq=FRToSq(ef,pr); const adj=pieceAt(state,adjSq); if (adj && adj.t==='P' && adj.c!==p.c) moves.push({kind:'move', from:p.sq, to: state.ep, capture:true, enPassant:true, capSq: adjSq}); } }
        } else if (p.t==='N'){
          const [f,r]=sqToFR(p.sq); const deltas=[[1,2],[2,1],[2,-1],[1,-2],[-1,-2],[-2,-1],[-2,1],[-1,2]];
          for (const [df,dr] of deltas){ const f2=f+df, r2=r+dr; if (!inBoard(f2,r2)) continue; const sq=FRToSq(f2,r2); const q=pieceAt(state,sq); if (q && q.c===p.c) continue; moves.push({kind:'move', from:p.sq, to:sq, capture:!!q}); }
        } else if (p.t==='B' || p.t==='R' || p.t==='Q'){
          const [f,r]=sqToFR(p.sq); const rays=[]; if (p.t!=='B'){ rays.push([1,0],[-1,0],[0,1],[0,-1]); } if (p.t!=='R'){ rays.push([1,1],[1,-1],[-1,1],[-1,-1]); }
          for (const [df,dr] of rays){ let f2=f+df, r2=r+dr; while (inBoard(f2,r2)){ const sq=FRToSq(f2,r2); const q=pieceAt(state,sq); if (!q) moves.push({kind:'move', from:p.sq, to:sq}); else { if (q.c!==p.c) moves.push({kind:'move', from:p.sq, to:sq, capture:true}); break; } f2+=df; r2+=dr; } }
        } else if (p.t==='K'){
          const [f,r]=sqToFR(p.sq); for (let df=-1; df<=1; df++) for (let dr=-1; dr<=1; dr++){ if (df===0&&dr===0) continue; const f2=f+df, r2=r+dr; if (!inBoard(f2,r2)) continue; const sq=FRToSq(f2,r2); const q=pieceAt(state,sq); if (q && q.c===p.c) continue; moves.push({kind:'move', from:p.sq, to:sq, capture:!!q}); }
        }
      }
      return moves;
    }

    function applyMove(state, mv){
      const s = cloneState(state); if (s.terminal) return s; s.morphFlashSq = null;
      if (mv.kind==='upgrade') return applyUpgradeChoice(s, mv.choice);
      if (mv.kind!=='move') return s;
      const mover = s.pieces.find(x=>x.sq===mv.from); if (!mover) return s;

      let victim=null; if (mv.capture){ if (mv.enPassant){ victim = s.pieces.find(x=>x.sq===mv.capSq)||null; s.pieces = s.pieces.filter(x=>x.sq!==mv.capSq); } else { victim = s.pieces.find(x=>x.sq===mv.to)||null; s.pieces = s.pieces.filter(x=>x.sq!==mv.to); } }

      mover.sq = mv.to; if (mover.t==='P') mover.hasMoved = true;

      if (mover.t==='P' && mv.double){ const [f,rFrom]=sqToFR(mv.from); const [_,rTo]=sqToFR(mv.to); const midR=(rFrom+rTo)/2; s.ep=FRToSq(f, midR); } else { s.ep=null; }

      // Ticks: end-of-turn for mover's color
      const side=mover.c; for (const p of s.pieces){ if (p.t==='P' && p.c===side){ if (p===mover) p.tick=0; else p.tick=Math.min(9,(p.tick||0)+1); } }

      // Heatmap: action squares are from, to, and capSq if EP
      const acted = new Set([mv.from, mv.to]); if (mv.enPassant && mv.capSq!=null) acted.add(mv.capSq);
      decayAndApplyHeat(s, acted);

      // UPDATED END CONDITION: game ends only when a side has no kings remaining
      const wKings = s.pieces.filter(p=>p.t==='K' && p.c==='w').length;
      const bKings = s.pieces.filter(p=>p.t==='K' && p.c==='b').length;
      if (wKings===0 || bKings===0){ s.terminal = { result: wKings>0 ? 'w' : (bKings>0 ? 'b' : 'draw'), reason:'All kings of a side captured' }; s.stm = (s.stm==='w'?'b':'w'); s.ply+=1; return s; }

      s.stm = s.stm==='w' ? 'b' : 'w'; s.ply += 1;
      return beginUpgradeFlow(s);
    }

    function beginUpgradeFlow(state){
      const s = cloneState(state); s.morphFlashSq=null; s.upgradeQueue=[]; s.awaitingUpgrade=null;
      const season = currentSeason(s.ply, s.seasonCfg);
      if (season==='Spring') performSpringSpawn(s);

      // Heatmap: season spawn squares count as action
      if (s.__lastSpawns && s.__lastSpawns.length){ decayAndApplyHeat(s, new Set(s.__lastSpawns)); s.__lastSpawns=null; }

      const pawns = s.pieces.filter(p=>p.t==='P' && p.c===s.stm);
      for (const p of pawns){ const choices=upgradeChoicesForPawn(p); if (choices.length>0) s.upgradeQueue.push({pawnSq:p.sq, choices}); }
      if (s.upgradeQueue.length>0){ s.awaitingUpgrade = s.upgradeQueue.shift(); }
      return s;
    }

    function performSpringSpawn(state){
      const side = state.stm; const king = state.pieces.find(p=>p.t==='K' && p.c===side); if (!king) return;
      const orth = orthSquaresOf(king.sq); const queens = orth.map(sq=> pieceAt(state, sq)).filter(p=>p && p.t==='Q' && p.c===side);
      const spawns=[];
      for (const q of queens){ const [f]=sqToFR(q.sq); const homeR = (side==='w')?6:1; const target=FRToSq(f, homeR); if (isEmpty(state, target)){ state.pieces.push({ t:'P', c:side, sq:target, tick:0, id:`${side}P#${Math.random().toString(36).slice(2,7)}`, hasMoved:false }); spawns.push(target); } }
      state.__lastSpawns = spawns;
    }

    function orthSquaresOf(sq){ const [f,r]=sqToFR(sq); const out=[]; const dirs=[[1,0],[-1,0],[0,1],[0,-1]]; for (const [df,dr] of dirs){ const f2=f+df, r2=r+dr; if (inBoard(f2,r2)) out.push(FRToSq(f2,r2)); } return out; }

    function applyUpgradeChoice(state, choice){
      const s = cloneState(state); const pending=s.awaitingUpgrade; if (!pending) return s;
      const p = s.pieces.find(x=> x.t==='P' && x.sq===pending.pawnSq && x.c===s.stm); if (!p){ s.awaitingUpgrade=null; return s; }
      p.t = choice; delete p.id; delete p.hasMoved; delete p.tick; s.morphFlashSq = p.sq;
      // Heat: upgrading on this square counts as action
      decayAndApplyHeat(s, new Set([p.sq]));
      if (s.upgradeQueue.length>0) s.awaitingUpgrade = s.upgradeQueue.shift(); else s.awaitingUpgrade=null; return s;
    }

    function deferUpgradeChoice(state){ const s=cloneState(state); if (!s.awaitingUpgrade) return s; s.morphFlashSq=null; s.awaitingUpgrade=null; s.upgradeQueue=[]; return s; }
    function skipUpgradeChoice(state){ const s=cloneState(state); if (!s.awaitingUpgrade) return s; s.morphFlashSq=null; s.awaitingUpgrade = s.upgradeQueue.length? s.upgradeQueue.shift() : null; return s; }

    // Heatmap core: decay all squares by 1; apply +1 to acted squares; cap at 3; trigger cast pulse when hitting 3
    function decayAndApplyHeat(state, actedSet){
      const heat = state.squareHeat.slice();
      for (let sq=0; sq<64; sq++){
        if (actedSet && actedSet.has(sq)){
          heat[sq] = Math.min(3, (heat[sq]||0) + 1);
          if (heat[sq]===3) state.lastCastAt[sq] = state.ply; // mark cast trigger
        } else {
          heat[sq] = Math.max(0, (heat[sq]||0) - 1);
        }
      }
      state.squareHeat = heat;
    }

    // Simple AI and eval (updated thresholds and terminal check)
    function evalState(state, persp){
      const vals={Q:900,R:500,B:330,N:320,P:100}; let score=0; for (const p of state.pieces){ const sgn=(p.c===persp)?1:-1; if (p.t!=='K') score+=sgn*(vals[p.t]||0); if (p.t==='P'){ const t=p.tick||0; const onStrip=isMidStripSq(p.sq); const minorThr=onStrip?3:6; const qThr=onStrip?5:8; if (t>=qThr) score+=sgn*430; else if (t===qThr-1) score+=sgn*200; if (t>=minorThr) score+=sgn*160; else if (t===minorThr-1) score+=sgn*90; if (onStrip) score+=sgn*35; } } const s1=cloneState(state); s1.stm=persp; s1.awaitingUpgrade=null; s1.upgradeQueue=[]; const s2=cloneState(state); s2.stm=(persp==='w'?'b':'w'); s2.awaitingUpgrade=null; s2.upgradeQueue=[]; score += (generateMoves(s1).length - generateMoves(s2).length) * 1.2; return score; }
    function aiPickMove(state){ if (state.awaitingUpgrade){ const choices=state.awaitingUpgrade.choices; const order=['Q','R','B','N','K']; const pick=order.find(x=>choices.includes(x))||choices[0]; return {kind:'upgrade', choice:pick}; } const persp=state.stm; const my=generateMoves(state); if (!my.length) return null; my.sort((a,b)=> (b.capture?1:0)-(a.capture?1:0)); let best=null, bestScore=-1e9; for (const mv of my){ const sAfter=applyMove(state, mv); if (sAfter.terminal) return mv; let sSim=sAfter; while (sSim.awaitingUpgrade){ const c=aiPickMove(sSim); if (!c||c.kind!=='upgrade') break; sSim=applyUpgradeChoice(sSim,c.choice); } const opp=generateMoves(sSim); let worst=+1e9; if (!opp.length){ worst=evalState(sSim,persp);} else { for (const omv of opp){ let sReply=applyMove(sSim, omv); while (sReply.awaitingUpgrade){ const c2=aiPickMove(sReply); if (!c2||c2.kind!=='upgrade') break; sReply=applyUpgradeChoice(sReply,c2.choice);} const sc=evalState(sReply,persp); if (sc<worst) worst=sc; } } const final=worst + (mv.capture?80:0); if (final>bestScore){ bestScore=final; best=mv; } } return best; }

    function App(){
      const [mode, setMode] = React.useState('human-ai');
      const [speed, setSpeed] = React.useState('normal');
      const [state, setState] = React.useState(()=> beginUpgradeFlow(makeInitialState()));
      const [selected, setSelected] = React.useState(null);
      const [moves, setMoves] = React.useState([]);
      const [flashSq, setFlashSq] = React.useState(null);
      const [running, setRunning] = React.useState(false);
      const [seasonFlash, setSeasonFlash] = React.useState(null);
      const [seasonBadge, setSeasonBadge] = React.useState(null);
      const lastSeasonRef = React.useRef(null);

      const sideToHuman = React.useMemo(()=>({ w: mode==='human-human' || mode==='human-ai', b: mode==='human-human' || mode==='ai-human' }), [mode]);
      const speedMs = speed==='instant' ? 0 : (speed==='fast' ? 250 : 600);

      React.useEffect(()=>{
        const curr = currentSeason(state.ply, state.seasonCfg);
        const prev = lastSeasonRef.current;
        if (curr !== prev){
          lastSeasonRef.current = curr;
          if (curr){ setSeasonBadge(curr); setTimeout(()=> setSeasonBadge(null), 1000); }
          if (curr === 'Spring'){ setSeasonFlash('Spring'); setTimeout(()=> setSeasonFlash(null), 700); }
        }
      }, [state.ply, state.seasonCfg]);

      React.useEffect(()=>{
        if (!running) return; if (state.terminal) return;
        if (state.awaitingUpgrade){ if (!sideToHuman[state.stm]){ const next=aiPickMove(state); if (next && next.kind==='upgrade'){ const s2=applyUpgradeChoice(state,next.choice); if (s2.morphFlashSq!=null){ setFlashSq(s2.morphFlashSq); setTimeout(()=>setFlashSq(null), 480);} setState(s2);} } return; }
        if (sideToHuman[state.stm]) return;
        const id=setTimeout(()=>{ const next=aiPickMove(state); if (!next){ setRunning(false); return; } const s2 = next.kind==='upgrade'? applyUpgradeChoice(state,next.choice) : applyMove(state,next); if (s2.morphFlashSq!=null){ setFlashSq(s2.morphFlashSq); setTimeout(()=>setFlashSq(null), 480);} setState(s2); }, speedMs);
        return ()=>clearTimeout(id);
      }, [running, state, sideToHuman, speedMs]);

      function onCellClick(sq){
        if (state.terminal) return; if (state.awaitingUpgrade) return; if (!sideToHuman[state.stm]) return;
        const p = pieceAt(state, sq);
        if (selected==null){ if (p && p.c===state.stm){ setSelected(sq); const ms=generateMoves(state).filter(m=>m.from===sq); setMoves(ms);} return; }
        if (selected===sq){ setSelected(null); setMoves([]); return; }
        const cand = moves.find(m=>m.to===sq);
        if (cand){ const s2=applyMove(state, cand); if (s2.morphFlashSq!=null){ setFlashSq(s2.morphFlashSq); setTimeout(()=>setFlashSq(null), 480);} setState(s2); setSelected(null); setMoves([]); }
        else { setSelected(null); setMoves([]); const p2=pieceAt(state,sq); if (p2 && p2.c===state.stm){ setSelected(sq); const ms=generateMoves(state).filter(m=>m.from===sq); setMoves(ms);} }
      }

      function onPick(choice){ const s2=applyUpgradeChoice(state, choice); if (s2.morphFlashSq!=null){ setFlashSq(s2.morphFlashSq); setTimeout(()=>setFlashSq(null), 480);} setState(s2); }
      function onWait(){ const s2=deferUpgradeChoice(state); setState(s2); }
      function onSkip(){ const s2=skipUpgradeChoice(state); setState(s2); }
      function reset(newMode){ if (newMode) setMode(newMode); setState(beginUpgradeFlow(makeInitialState())); setSelected(null); setMoves([]); setRunning(false); }

      const [boardW, setBoardW] = React.useState(600);
      React.useEffect(()=>{ function onResize(){ const w=Math.min(window.innerWidth, 900) - 32; setBoardW(Math.max(280, w)); } onResize(); window.addEventListener('resize', onResize); return ()=>window.removeEventListener('resize', onResize); }, []);

      const grid=[]; for (let r=0;r<8;r++){ for (let f=0;f<8;f++){ grid.push(FRToSq(f,r)); } }
      const season = currentSeason(state.ply, state.seasonCfg) || 'None';

      return (
        <div className="w-full h-full flex flex-col items-center">
          <div className="w-full max-w-5xl px-4 pt-6 pb-3 flex items-center justify-between">
            <div className="text-xl font-extrabold tracking-tight neon">TurboChess v0.4.2 — Mid-Strip Rebalance + Multi-King End</div>
            <div className="flex items-center gap-2">
              <select className="px-2 py-1 rounded-md glass" value={mode} onChange={e=>reset(e.target.value)}>
                <option value="human-ai">Human (White) vs AI</option>
                <option value="ai-human">AI vs Human (Black)</option>
                <option value="human-human">Human vs Human</option>
                <option value="ai-ai">AI vs AI</option>
              </select>
              <select className="px-2 py-1 rounded-md glass" value={speed} onChange={e=>setSpeed(e.target.value)}>
                <option value="normal">Speed: Normal</option>
                <option value="fast">Speed: Fast</option>
                <option value="instant">Speed: Instant</option>
              </select>
              <button className="px-3 py-1 rounded-md glass hover:bg-white/10" onClick={()=>setRunning(r=>!r)}>{running? 'Pause' : 'Play'}</button>
              <button className="px-3 py-1 rounded-md glass hover:bg-white/10" onClick={()=>reset()}>Reset</button>
              {state.awaitingUpgrade && (
                <div className="flex gap-2">
                  <button className="px-3 py-1 rounded-md glass hover:bg-white/10" onClick={()=>onSkip()}>Skip This Pawn</button>
                  <button className="px-3 py-1 rounded-md glass hover:bg-white/10" onClick={()=>onWait()}>Defer All</button>
                </div>
              )}
            </div>
          </div>

          <div className="text-sm opacity-80 mb-2">Season: <span className="font-semibold">{season}</span> <span className="opacity-60">(starts after 5 moves, lasts 8 full moves)</span></div>

          <div className="relative" style={{width: boardW, aspectRatio:'1/1'}}>
            <div className={`board glass rounded-lg overflow-hidden ${seasonFlash==='Spring' ? 'spring-flash' : ''}`} style={{width:'100%', height:'100%'}}>
              {grid.map((sq)=>{
                const f=sq%8, r=Math.floor(sq/8);
                const isLight = (f+r)%2===0; const p = pieceAt(state, sq);
                const isSel = selected===sq; const ms = moves.filter(m=>m.to===sq && m.kind==='move');
                const heat = state.squareHeat[sq]||0; const castPulse = state.lastCastAt[sq]===state.ply && heat===3;
                return (
                  <div key={sq} className={`cell ${isLight? 'light':'dark'} ${r===3||r===4? 'midlineGlow':''} ${isSel? 'sel':''}`} onClick={()=>onCellClick(sq)}>
                    <div className="sqLabel">{"abcdefgh"[f]}{"87654321"[r]}</div>
                    {p && <Piece p={p} />}
                    {p && p.t==='P' && <PawnHUD p={p} />}
                    {heat>0 && <div className={`heat ${heat===1?'heat-1': heat===2?'heat-2':'heat-3'}`} />}
                    {castPulse && <div className="gold-cast" />}
                    {ms.length>0 && <div className="moveDot" />}
                    {flashSq===sq && <div className="flash" />}
                  </div>
                );
              })}
              <HexLayer />
              {seasonBadge && (
                <div className="badge glass" style={{background:'rgba(80,255,120,0.12)', border:'1px solid rgba(80,255,120,0.35)'}}>{seasonBadge}</div>
              )}
            </div>
          </div>

          {state.awaitingUpgrade && (
            <div className="modalOverlay">
              <div className="modal glass">
                <div className="text-lg font-bold mb-2">Choose Upgrade</div>
                <div className="text-xs mb-2 opacity-80">Eligible choices depend on pawn ticks and position (mid-strip N/B/R at 3; Queen at 5; 9 ticks unlocks King anywhere).</div>
                <div className="flex flex-wrap gap-2 mb-3">
                  {state.awaitingUpgrade.choices.map(ch => (
                    <button key={ch} onClick={()=>onPick(ch)} className="pickerBtn glass hover:bg-white/10 px-3">
                      {ch==='Q'? '♕ Q' : ch==='R'? '♖ R' : ch==='B'? '♗ B' : ch==='N'? '♘ N' : '♔ K'}
                    </button>
                  ))}
                </div>
                <div className="flex justify-between">
                  <button onClick={()=>onSkip()} className="px-3 py-1 rounded-md glass hover:bg-white/10">Skip This Pawn</button>
                  <button onClick={()=>onWait()} className="px-3 py-1 rounded-md glass hover:bg-white/10">Defer All</button>
                </div>
              </div>
            </div>
          )}

          <div className="w-full max-w-5xl px-4 py-4 text-sm opacity-80 space-y-2">
            <p>Pawns gain +1 tick at end of their side's turns (except the pawn that moved, which resets). Mid-strip pawns now get N/B/R at 3 ticks and Queen at 5 ticks. Off-strip: 6 ticks → N/B/R; 8 ticks → Queen. 9 ticks → King anywhere.</p>
            <p>Spring (global seasons) begins after 5 full moves and lasts 8; at the start of your turn, each of your queens orthogonally adjacent to your king spawns 1 pawn on its file at the home pawn rank if empty.</p>
            <p>I Ching heatmap: any action on a square (move from/to, capture, EP cap square, upgrades, spring spawns) raises its heat by +1 (max 3). Each full move without action on that square reduces heat by 1. When heat hits 3, the square casts (gold pulse). Mechanics will hook into this later.</p>
            <p>Game end: the game only ends when one side has no kings remaining (multi-king support).</p>
          </div>
        </div>
      );
    }

    function PawnHUD({p}){ const t=p.tick||0; const onStrip=isMidStripSq(p.sq); const minor=onStrip?3:6; const qThr=onStrip?5:8; return (<div className="hud">T:{t} / NBR:{minor} Q:{qThr} K:9</div>); }

    function Piece({p}){
      const glyph = p.t==='K'?'♔': p.t==='Q'?'♕': p.t==='R'?'♖': p.t==='B'?'♗': p.t==='N'?'♘': '♙';
      const cls = p.c==='w'? 'w':'b';
      return (<div className={`piece ${cls}`}><span>{glyph}</span></div>);
    }

    function HexLayer(){ const cells=[]; for (let i=0;i<64;i++) cells.push(i); const glyphs=['䷀','䷁','䷂','䷃','䷄','䷅','䷆','䷇','䷈','䷉','䷊','䷋','䷌','䷍','䷎','䷏']; return (<div className="hexLayer">{cells.map(i=> <div key={i} className="hexCell">{glyphs[i%glyphs.length]}</div>)}</div>); }

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>
