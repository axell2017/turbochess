<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TurboChess v0.3 — Upgrade Picker + AI vs AI</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root { --bg:#0a0f1a; --fg:#cfe8ff; --cyan:#48e1ff; --mag:#ff5ad6; --gold:#ffde6b; --green:#5bff95; --amber:#ffb35c; --blue:#77b5ff; }
    html, body, #root { height: 100%; margin: 0; background: radial-gradient(1200px 800px at 50% 10%, #0e1630, #070b14 70%, #05060a); color: var(--fg); font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; }

    .glass { backdrop-filter: blur(6px) saturate(120%); background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02)); border: 1px solid rgba(255,255,255,0.15); box-shadow: 0 10px 40px rgba(0,0,0,0.5), inset 0 0 60px rgba(255,255,255,0.04); }
    .neon { text-shadow: 0 0 10px rgba(72,225,255,0.7); }
    .midlineGlow { box-shadow: inset 0 0 25px rgba(72,225,255,0.5); }

    .board { position: relative; display: grid; grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr); aspect-ratio: 1/1; }
    .cell { position: relative; display:flex; align-items:center; justify-content:center; font-weight:600; }
    .light { background: rgba(255,255,255,0.06); }
    .dark { background: rgba(0,0,0,0.25); }
    .sqLabel { position:absolute; left:6px; bottom:4px; opacity:0.35; font-size:10px; }

    .hud { position:absolute; top:6px; right:6px; font-size:10px; padding:2px 6px; border-radius:999px; background: rgba(10, 180, 255, 0.12); border:1px solid rgba(72,225,255,0.45); color:#bfefff; text-shadow:0 0 8px rgba(72,225,255,0.6); }

    .piece { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-size:28px; filter: drop-shadow(0 6px 18px rgba(0,0,0,0.6)); }
    .w { color:#e6f6ff; text-shadow:0 0 6px rgba(72,225,255,0.7); }
    .b { color:#ffd6f3; text-shadow:0 0 6px rgba(255,90,214,0.7); }

    .sel { outline: 2px solid rgba(72,225,255,0.9); box-shadow: inset 0 0 20px rgba(72,225,255,0.55); }
    .moveDot { width:14px; height:14px; border-radius:999px; background: radial-gradient(circle at 30% 30%, rgba(72,225,255,0.9), rgba(72,225,255,0.1)); box-shadow:0 0 14px rgba(72,225,255,0.8); }

    @keyframes morphFlash { 0% { opacity:0; transform:scale(0.8);} 40%{opacity:1; transform:scale(1.15);} 100% { opacity:0; transform:scale(1);} }
    .flash { pointer-events:none; position:absolute; inset:8px; border-radius:8px; background: radial-gradient(circle, rgba(72,225,255,0.6), rgba(255,255,255,0.05) 60%, rgba(0,0,0,0) 70%); animation: morphFlash 450ms ease-out; }

    /* Seasons overlay (future optional effects) */
    .seasons { pointer-events:none; position:absolute; inset:0; display:grid; grid-template-columns:1fr 1fr; grid-template-rows:1fr 1fr; mix-blend-mode:screen; }
    .season { opacity:0.16; }

    .hexLayer { position:absolute; inset:0; display:grid; grid-template-columns:repeat(8, 1fr); grid-template-rows:repeat(8, 1fr); pointer-events:none; }
    .hexCell { display:flex; align-items:center; justify-content:center; opacity:0.12; font-size:10px; }

    a, button { outline:none; }

    .modalOverlay { position:fixed; inset:0; background: rgba(0,0,0,0.6); display:flex; align-items:center; justify-content:center; z-index:50; }
    .modal { width: 340px; border-radius: 12px; padding: 16px; }
    .pickerBtn { min-width:56px; height:42px; border-radius:10px; font-weight:700; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    // TurboChess v0.3 — Upgrade Picker + AI vs AI

    const FILES = ['a','b','c','d','e','f','g','h'];
    const RANKS = ['8','7','6','5','4','3','2','1'];
    const IDX = (f,r) => r*8+f; // 0..63

    const initialPieces = () => {
      const pieces = [];
      // Pawns with tick counter
      for (let f=0; f<8; f++) {
        pieces.push({ t:'P', c:'w', sq: IDX(f,6), tick:0, id:`wP${f}` , hasMoved:false});
        pieces.push({ t:'P', c:'b', sq: IDX(f,1), tick:0, id:`bP${f}` , hasMoved:false});
      }
      // Back ranks
      const back = ['R','N','B','Q','K','B','N','R'];
      for (let f=0; f<8; f++) {
        pieces.push({ t:back[f], c:'w', sq: IDX(f,7) });
        pieces.push({ t:back[f], c:'b', sq: IDX(f,0) });
      }
      return pieces;
    };

    function cloneState(s){ return JSON.parse(JSON.stringify(s)); }
    function sqToFR(sq){ return [sq%8, Math.floor(sq/8)]; }
    function FRToSq(f,r){ return r*8+f; }
    function isMidStripSq(sq){ const [,r]=sqToFR(sq); return r===3 || r===4; }

    function makeInitialState(){
      return {
        pieces: initialPieces(),
        stm: 'w',
        ep: null, // en passant target square index
        ply: 0,
        morphFlashSq: null,
        // v0.3 picker flow
        upgradeQueue: [],
        awaitingUpgrade: null, // { pawnId, choices: ['N','B','R','Q'] }
      };
    }

    function pieceAt(state, sq){ return state.pieces.find(p=>p.sq===sq); }
    function inBoard(f,r){ return f>=0 && f<8 && r>=0 && r<8; }
    function isEmpty(state, sq){ return !pieceAt(state, sq); }

    // New thresholds
    function upgradeChoicesForPawn(p){
      const t = p.tick || 0;
      const onStrip = isMidStripSq(p.sq);
      const set = new Set();
      if (t >= 6) { set.add('N'); set.add('B'); set.add('R'); }
      if (t >= 9) { set.add('Q'); }
      if (onStrip && t >= 3) { set.add('N'); set.add('B'); set.add('R'); set.add('Q'); }
      return Array.from(set);
    }

    function generateMoves(state){
      // Pseudo-legal moves (no check detection yet).
      const moves = [];
      const dir = { w: -1, b: 1 };

      for (const p of state.pieces) {
        if (p.c !== state.stm) continue;

        if (p.t === 'P') {
          const [f,r] = sqToFR(p.sq);

          // Forward 1
          const r1 = r + dir[p.c];
          if (inBoard(f,r1) && isEmpty(state, FRToSq(f,r1))) {
            moves.push({ kind:'move', from:p.sq, to: FRToSq(f,r1) });

            // Forward 2 on first move if clear
            if (!p.hasMoved) {
              const r2 = r + 2*dir[p.c];
              if (inBoard(f,r2) && isEmpty(state, FRToSq(f,r2)) && isEmpty(state, FRToSq(f,r1))) {
                moves.push({ kind:'move', from:p.sq, to: FRToSq(f,r2), double:true });
              }
            }
          }

          // Diagonal captures
          for (const df of [-1, +1]){
            const f2 = f+df, r2 = r + dir[p.c];
            if (!inBoard(f2,r2)) continue;
            const sq = FRToSq(f2,r2);
            const victim = pieceAt(state, sq);
            if (victim && victim.c !== p.c) {
              moves.push({ kind:'move', from:p.sq, to:sq, capture:true });
            }
          }

          // En passant (standard)
          if (state.ep != null) {
            const [ef, er] = sqToFR(state.ep);
            const [pf, pr] = sqToFR(p.sq);
            if (er === pr + dir[p.c] && Math.abs(ef - pf) === 1){
              const adjSq = FRToSq(ef, pr);
              const adj = pieceAt(state, adjSq);
              if (adj && adj.t==='P' && adj.c!==p.c) {
                moves.push({ kind:'move', from:p.sq, to: state.ep, capture:true, enPassant:true, capSq: adjSq });
              }
            }
          }

        } else if (p.t === 'N') {
          const [f,r]=sqToFR(p.sq);
          const deltas=[[1,2],[2,1],[2,-1],[1,-2],[-1,-2],[-2,-1],[-2,1],[-1,2]];
          for (const [df,dr] of deltas){
            const f2=f+df, r2=r+dr; if (!inBoard(f2,r2)) continue; const sq=FRToSq(f2,r2);
            const q=pieceAt(state,sq); if (q && q.c===p.c) continue; moves.push({kind:'move', from:p.sq, to:sq, capture: !!q});
          }
        } else if (p.t === 'B' || p.t === 'R' || p.t === 'Q') {
          const [f,r]=sqToFR(p.sq);
          const rays = [];
          if (p.t!=='B'){ rays.push([1,0],[-1,0],[0,1],[0,-1]); }
          if (p.t!=='R'){ rays.push([1,1],[1,-1],[-1,1],[-1,-1]); }
          for (const [df,dr] of rays){
            let f2=f+df, r2=r+dr;
            while (inBoard(f2,r2)){
              const sq=FRToSq(f2,r2); const q=pieceAt(state,sq);
              if (!q){ moves.push({kind:'move', from:p.sq, to:sq}); }
              else { if (q.c!==p.c) moves.push({kind:'move', from:p.sq, to:sq, capture:true}); break; }
              f2+=df; r2+=dr;
            }
          }
        } else if (p.t === 'K') {
          const [f,r]=sqToFR(p.sq);
          for (let df=-1; df<=1; df++) for (let dr=-1; dr<=1; dr++){
            if (df===0 && dr===0) continue; const f2=f+df, r2=r+dr; if (!inBoard(f2,r2)) continue; const sq=FRToSq(f2,r2); const q=pieceAt(state,sq); if (q && q.c===p.c) continue; moves.push({kind:'move', from:p.sq, to:sq, capture:!!q});
          }
          // No castling logic in v0.3
        }
      }
      return moves;
    }

    function applyMove(state, mv){
      const s = cloneState(state);
      s.morphFlashSq = null;

      if (mv.kind !== 'move') return state; // only moves end turns now

      const mover = s.pieces.find(x=>x.sq===mv.from);
      if (!mover) return state;

      // Handle capture
      if (mv.capture){
        if (mv.enPassant){
          s.pieces = s.pieces.filter(x=>x.sq!==mv.capSq);
        } else {
          s.pieces = s.pieces.filter(x=>x.sq!==mv.to);
        }
      }

      // Move piece
      mover.sq = mv.to;
      if (mover.t==='P'){
        mover.hasMoved = true;
      }

      // Set/clear en passant
      if (mover.t==='P' && mv.double){
        const [f, rFrom] = sqToFR(mv.from);
        const [_, rTo] = sqToFR(mv.to);
        const midR = (rFrom + rTo)/2;
        s.ep = FRToSq(f, midR);
      } else {
        s.ep = null;
      }

      // End-of-turn ticks: all pawns of mover's color +1, except the pawn that moved resets to 0
      const side = mover.c;
      for (const p of s.pieces){
        if (p.t==='P' && p.c===side){
          if (p === mover){
            p.tick = 0; // the pawn that moved resets
          } else {
            p.tick = Math.min(9, (p.tick||0) + 1);
          }
        }
      }

      // Switch side
      s.stm = s.stm==='w' ? 'b' : 'w';
      s.ply += 1;

      // Start-of-turn upgrades for new side to move (queue + picker)
      return beginUpgradeFlow(s);
    }

    function beginUpgradeFlow(state){
      const s = cloneState(state);
      s.morphFlashSq = null;
      s.upgradeQueue = [];
      s.awaitingUpgrade = null;

      // Collect eligible pawns for the side to move
      const pawns = s.pieces.filter(p=> p.t==='P' && p.c===s.stm);
      for (const p of pawns){
        const choices = upgradeChoicesForPawn(p);
        if (choices.length>0){
          s.upgradeQueue.push({ pawnSq: p.sq, choices });
        }
      }

      if (s.upgradeQueue.length>0){
        const next = s.upgradeQueue.shift();
        s.awaitingUpgrade = next;
      }
      return s;
    }

    function applyUpgradeChoice(state, choice){
      const s = cloneState(state);
      const pending = s.awaitingUpgrade;
      if (!pending) return s;
      const p = s.pieces.find(x=> x.t==='P' && x.sq===pending.pawnSq && x.c===s.stm);
      if (!p) { s.awaitingUpgrade = null; return s; }
      // Transform
      p.t = choice; // 'N','B','R','Q'
      delete p.id; delete p.hasMoved; delete p.tick;
      s.morphFlashSq = p.sq;

      // Queue next if any
      if (s.upgradeQueue.length>0){
        s.awaitingUpgrade = s.upgradeQueue.shift();
      } else {
        s.awaitingUpgrade = null;
      }
      return s;
    }

    // Medium AI: shallow lookahead + reward imminent metamorph
    function evalState(state, persp){
      const vals = {Q:900,R:500,B:330,N:320,P:100};
      let score = 0;
      for (const p of state.pieces){
        const sgn = (p.c===persp)? 1 : -1;
        if (p.t!=='K') score += sgn * (vals[p.t]||0);
        if (p.t==='P'){
          const t = p.tick||0;
          // Bonuses around thresholds
          // Off-strip: 6 for minor, 9 for queen; On-strip: 3 for both
          const onStrip = isMidStripSq(p.sq);
          const minThr = onStrip ? 3 : 6;
          const qThr = onStrip ? 3 : 9;
          if (t >= qThr) score += sgn * 430; // imminent queen potential
          else if (t === qThr-1) score += sgn * 200;
          if (t >= minThr) score += sgn * 160; // minor potential
          else if (t === minThr-1) score += sgn * 90;
          if (onStrip) score += sgn * 35;
        }
      }
      // Mobility proxy
      const s1 = cloneState(state); s1.stm = persp; s1.awaitingUpgrade=null; s1.upgradeQueue=[];
      const s2 = cloneState(state); s2.stm = (persp==='w'?'b':'w'); s2.awaitingUpgrade=null; s2.upgradeQueue=[];
      score += (generateMoves(s1).length - generateMoves(s2).length) * 1.2;
      return score;
    }

    function aiPickMove(state){
      // If upgrade choice is pending for AI, auto-pick best by value
      if (state.awaitingUpgrade){
        const choices = state.awaitingUpgrade.choices;
        const order = ['Q','R','B','N'];
        const pick = choices.includes('Q') ? 'Q' : (choices.includes('R')?'R':(choices.includes('B')?'B':'N'));
        return { kind:'upgrade', choice: pick };
      }

      const persp = state.stm;
      const myMoves = generateMoves(state);
      if (myMoves.length===0) return null;

      // Order: prioritize captures (simple)
      myMoves.sort((a,b)=> (b.capture?1:0)-(a.capture?1:0));

      let best=null, bestScore=-1e9;
      for (const mv of myMoves){
        const sAfter = applyMove(state, mv);
        // If opponent has pending upgrades, simulate auto-best choices for them too
        let sSim = sAfter;
        while (sSim.awaitingUpgrade){
          const c = aiPickMove(sSim); // returns upgrade kind
          if (!c || c.kind!=='upgrade') break;
          sSim = applyUpgradeChoice(sSim, c.choice);
        }

        // Opp reply (min)
        const oppMoves = generateMoves(sSim);
        let worst = +1e9;
        if (oppMoves.length===0){
          worst = evalState(sSim, persp);
        } else {
          for (const omv of oppMoves){
            let sReply = applyMove(sSim, omv);
            // Resolve their upgrades too
            while (sReply.awaitingUpgrade){
              const c2 = aiPickMove(sReply);
              if (!c2 || c2.kind!=='upgrade') break;
              sReply = applyUpgradeChoice(sReply, c2.choice);
            }
            const sc = evalState(sReply, persp);
            if (sc < worst) worst = sc;
          }
        }
        // Small immediate bias for captures
        const finalScore = worst + (mv.capture? 80 : 0);
        if (finalScore > bestScore){ bestScore=finalScore; best=mv; }
      }
      return best;
    }

    // UI
    function App(){
      const [mode, setMode] = React.useState('human-ai'); // 'human-human' | 'human-ai' | 'ai-human' | 'ai-ai'
      const [speed, setSpeed] = React.useState('normal'); // 'instant' | 'fast' | 'normal'
      const [state, setState] = React.useState(()=> beginUpgradeFlow(makeInitialState()));
      const [selected, setSelected] = React.useState(null);
      const [moves, setMoves] = React.useState([]);
      const [flashSq, setFlashSq] = React.useState(null);
      const [running, setRunning] = React.useState(false);

      const sideToHuman = React.useMemo(()=>{
        return {
          w: mode==='human-human' || mode==='human-ai',
          b: mode==='human-human' || mode==='ai-human',
        };
      }, [mode]);

      const speedMs = speed==='instant' ? 0 : (speed==='fast' ? 250 : 600);

      // AI loop (handle upgrade choices and moves)
      React.useEffect(()=>{
        if (!running) return;
        // Pause on picker regardless of side
        if (state.awaitingUpgrade) return;
        // If it's a human side, wait for click
        if (sideToHuman[state.stm]) return;

        const id = setTimeout(()=>{
          const next = aiPickMove(state);
          if (!next){ setRunning(false); return; }
          if (next.kind==='upgrade'){
            const s2 = applyUpgradeChoice(state, next.choice);
            if (s2.morphFlashSq!=null){ setFlashSq(s2.morphFlashSq); setTimeout(()=>setFlashSq(null), 480); }
            setState(s2);
          } else {
            const s2 = applyMove(state, next);
            if (s2.morphFlashSq!=null){ setFlashSq(s2.morphFlashSq); setTimeout(()=>setFlashSq(null), 480); }
            setState(s2);
          }
        }, speedMs);
        return ()=>clearTimeout(id);
      }, [running, state, sideToHuman, speedMs]);

      function onCellClick(sq){
        if (state.awaitingUpgrade) return; // must resolve picker first
        if (!sideToHuman[state.stm]) return;
        const p = pieceAt(state, sq);
        if (selected==null){
          if (p && p.c===state.stm){
            setSelected(sq);
            const ms = generateMoves(state).filter(m=>m.from===sq);
            setMoves(ms);
          }
          return;
        }
        if (selected===sq){ setSelected(null); setMoves([]); return; }
        const cand = moves.find(m=>m.to===sq);
        if (cand){
          const s2 = applyMove(state, cand);
          if (s2.morphFlashSq!=null){ setFlashSq(s2.morphFlashSq); setTimeout(()=>setFlashSq(null), 480); }
          setState(s2); setSelected(null); setMoves([]);
        } else {
          setSelected(null); setMoves([]);
          const p2 = pieceAt(state, sq);
          if (p2 && p2.c===state.stm){
            setSelected(sq);
            const ms = generateMoves(state).filter(m=>m.from===sq);
            setMoves(ms);
          }
        }
      }

      function onPick(choice){
        const s2 = applyUpgradeChoice(state, choice);
        if (s2.morphFlashSq!=null){ setFlashSq(s2.morphFlashSq); setTimeout(()=>setFlashSq(null), 480); }
        setState(s2);
      }

      function reset(newMode){
        if (newMode) setMode(newMode);
        setState(beginUpgradeFlow(makeInitialState()));
        setSelected(null); setMoves([]); setRunning(false);
      }

      const [boardW, setBoardW] = React.useState(600);
      React.useEffect(()=>{
        function onResize(){
          const w = Math.min(window.innerWidth, 900) - 32;
          setBoardW(Math.max(280, w));
        }
        onResize();
        window.addEventListener('resize', onResize);
        return ()=>window.removeEventListener('resize', onResize);
      }, []);

      const grid = [];
      for (let r=0; r<8; r++){
        for (let f=0; f<8; f++){
          const sq = FRToSq(f,r);
          grid.push(sq);
        }
      }

      const seasonOn = true; // visual placeholder; mechanics coming soon

      return (
        <div className="w-full h-full flex flex-col items-center">
          <div className="w-full max-w-5xl px-4 pt-6 pb-3 flex items-center justify-between">
            <div className="text-xl font-extrabold tracking-tight neon">TurboChess v0.3 — Upgrade Picker + AI vs AI</div>
            <div className="flex items-center gap-2">
              <select className="px-2 py-1 rounded-md glass" value={mode} onChange={e=>reset(e.target.value)}>
                <option value="human-ai">Human (White) vs AI</option>
                <option value="ai-human">AI vs Human (Black)</option>
                <option value="human-human">Human vs Human</option>
                <option value="ai-ai">AI vs AI</option>
              </select>
              <select className="px-2 py-1 rounded-md glass" value={speed} onChange={e=>setSpeed(e.target.value)}>
                <option value="normal">Speed: Normal</option>
                <option value="fast">Speed: Fast</option>
                <option value="instant">Speed: Instant</option>
              </select>
              <button className="px-3 py-1 rounded-md glass hover:bg-white/10" onClick={()=>setRunning(r=>!r)}>{running? 'Pause' : 'Play'}</button>
              <button className="px-3 py-1 rounded-md glass hover:bg-white/10" onClick={()=>reset()}>Reset</button>
            </div>
          </div>

          <div className="relative" style={{width: boardW, aspectRatio:'1/1'}}>
            <div className="board glass rounded-lg overflow-hidden" style={{width: '100%', height: '100%'}}>
              {grid.map((sq)=>{
                const f = sq % 8; const r = Math.floor(sq/8);
                const isLight = (f+r)%2===0;
                const p = pieceAt(state, sq);
                const midline = (r===3 || r===4);
                const isSel = selected===sq;
                const ms = moves.filter(m=>m.to===sq && m.kind==='move');
                return (
                  <div key={sq} className={`cell ${isLight? 'light':'dark'} ${midline? 'midlineGlow' : ''} ${isSel? 'sel':''}`} onClick={()=>onCellClick(sq)}>
                    <div className="sqLabel">{"abcdefgh"[f]}{"87654321"[r]}</div>
                    {p && <Piece p={p} />}
                    {p && p.t==='P' && <PawnHUD p={p} />}
                    {ms.length>0 && <div className="moveDot" />}
                    {flashSq===sq && <div className="flash" />}
                  </div>
                );
              })}

              {seasonOn && <div className="seasons">
                <div className="season" style={{gridArea:'1 / 1 / 2 / 2', background:'radial-gradient(60% 60% at 30% 30%, rgba(91,255,149,0.4), rgba(0,0,0,0))'}}></div>
                <div className="season" style={{gridArea:'1 / 2 / 2 / 3', background:'radial-gradient(60% 60% at 70% 30%, rgba(255,222,107,0.4), rgba(0,0,0,0))'}}></div>
                <div className="season" style={{gridArea:'2 / 1 / 3 / 2', background:'radial-gradient(60% 60% at 30% 70%, rgba(255,179,92,0.4), rgba(0,0,0,0))'}}></div>
                <div className="season" style={{gridArea:'2 / 2 / 3 / 3', background:'radial-gradient(60% 60% at 70% 70%, rgba(119,181,255,0.4), rgba(0,0,0,0))'}}></div>
              </div>}

              <HexLayer />
            </div>
          </div>

          <div className="w-full max-w-5xl px-4 py-4 text-sm opacity-80">
            <p>
              New in v0.3: Start-of-turn upgrade picker. Pawns that have accumulated 6 ticks (off-strip) may become N/B/R (no queen). Queens require 9 ticks off-strip, or just 3 ticks on the mid-strip (ranks 4–5). Multiple eligible pawns are queued one-by-one before your move. Toggle AI vs AI to watch them battle.
            </p>
          </div>

          {state.awaitingUpgrade && (
            <div className="modalOverlay">
              <div className="modal glass">
                <div className="text-lg font-bold mb-2">Choose Upgrade</div>
                <div className="text-xs mb-4 opacity-80">Eligible choices are based on pawn ticks and position (mid-strip allows faster queen).</div>
                <div className="flex flex-wrap gap-2">
                  {state.awaitingUpgrade.choices.map(ch => (
                    <button key={ch} onClick={()=>onPick(ch)} className="pickerBtn glass hover:bg-white/10 px-3">
                      {ch==='Q'?'♕ Q': ch==='R'?'♖ R': ch==='B'?'♗ B':'♘ N'}
                    </button>
                  ))}
                </div>
              </div>
            </div>
          )}
        </div>
      );
    }

    function PawnHUD({p}){
      const t = p.tick||0;
      const onStrip = isMidStripSq(p.sq);
      const minorThr = onStrip ? 3 : 6;
      const qThr = onStrip ? 3 : 9;
      return (
        <div className="hud">
          T:{t} / NBR:{minorThr} Q:{qThr}
        </div>
      );
    }

    function Piece({p}){
      const glyph = (()=>{
        switch(p.t){
          case 'K': return '♔';
          case 'Q': return '♕';
          case 'R': return '♖';
          case 'B': return '♗';
          case 'N': return '♘';
          case 'P': return '♙';
          default: return '?';
        }
      })();
      const cls = p.c==='w' ? 'w' : 'b';
      return (
        <div className={`piece ${cls}`}>
          <span>{glyph}</span>
        </div>
      );
    }

    function HexLayer(){
      const cells = [];
      for (let i=0;i<64;i++) cells.push(i);
      const glyphs = ['䷀','䷁','䷂','䷃','䷄','䷅','䷆','䷇','䷈','䷉','䷊','䷋','䷌','䷍','䷎','䷏'];
      return (
        <div className="hexLayer">
          {cells.map((i)=>{
            return <div key={i} className="hexCell">{glyphs[i%glyphs.length]}</div>;
          })}
        </div>
      );
    }

    // Entry
    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>
